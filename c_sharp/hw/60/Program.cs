// Сформируйте трёхмерный массив из неповторяющихся двузначных чисел.
// Напишите программу, которая будет построчно выводить массив,
// добавляя индексы каждого элемента.
// Массив размером 2 x 2 x 2
// 66(0,0,0) 25(0,1,0) 111 121
// 34(1,0,0) 41(1,1,0) 211 221
// 27(0,0,1) 90(0,1,1) 112 122
// 26(1,0,1) 55(1,1,1) 212 222 

//           0        1               0        1
// 0   {{{66, 27},{25, 90}}        {66 27}  {34 26}
//         0   1    0   1          {25 90}  {41 55}
// 1    {{34, 26},{41, 55}}}

Console.Clear();
Console.Write("Enter the number of the first rank elements: ");
int rank1 = int.Parse(Console.ReadLine());
Console.Write("Enter the number of the second rank elements: ");
int rank2 = int.Parse(Console.ReadLine());
Console.Write("Enter the number of the third rank elements: ");
int rank3 = int.Parse(Console.ReadLine());
GetTripleArray(rank1, rank2, rank3);

void GetTripleArray (int rank1Num, int rank2Num, int rank3Num){
    int[,,] result = new int[rank1Num, rank2Num, rank3Num];
    for (int i = 0; i < rank1Num; i++)
    {
        for (int j = 0; j < rank2Num; j++)
        {
            for (int k = 0; k < rank3Num; k++)
            {
                result[i,j,k] = rank1Num*rank1Num*i + rank2Num*j + k + 10;
                Console.Write($"{result[i, j, k]}({i},{j},{k}) ");
            }
            Console.WriteLine();
        }
        Console.WriteLine();
    }
}

//      Уравнение вывода неповторяющихся элементов вывел методом проб и ошибок.
// Рассуждал так: если каждый элемент имеет свой уникальный "адрес" в массиве,
// то, используя его, можно получить уникальное число. К сожалению, полученное
// уравнение выполняет свою функцию только при одинаковых размерах всех рангов массива.
// Был гораздо более простой и универсальный способ, но он отменялся условием двузначности
// элементов.
//      Можно было сделать рандомную генерацию значения элемента, проверку массива
// на наличие такого элемента и, в случае совпадения, перезадать его снова и повторить.
// Но это было бы слишком в лоб и не оптимально.
//      Другой вариант - задать первый элемент 10 и остальные += 1, но это еще более
// тупо, чем второй вариант, хотя и наболее оптимально при данных условиях задачи.